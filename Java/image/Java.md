### Java ###

* 线程休息室

  在虚拟机规范中存在一个*wait set*(wait set 又被称为线程休息室)的概念:线程调用了某个对象的wait方法之后都会被加入与该对象monitor关联的wait set中,并且释放monitor的所有权.

* Java中的Monitor

  实质上,Java的Object类本身就是监视者对象,Java对于Monitor Object模式做了内建的支持.

  * Object类本身就是监视者对象
  * 每个Object都带了一把看不见的锁,通常叫**内部锁/Monitor锁/Instrinsic Lock**,这把锁就是**监控锁**
  * synchronized关键字修饰方法和代码块就是同步方法
  * wait()/notif()/notifyAll()方法构成**监控条件(Monitor Condition)**

  ***工作原理:***

  1. 线程进入同步方法中
  2. 为了继续执行临界区代码,线程必须获取Monitor锁.如果获取锁成功,将成为该监视者对象的拥有者.任一时刻内,监视者对象只属于一个活动线程(**The Owner**)
  3. 拥有监视者对象的线程可以调用*wait()*进入**等待集合(Wait Set)**,同时释放监视锁,进入等待状态
  4. 其他线程调用*notify()/notifyAll()*接口唤醒等待集合中的线程,这些等待的线程需要**重新获取监视锁后**才能执行*wait()*之后的代码
  5. 同步方法执行完毕了,线程退出临界区,并释放监视器

  ***被synchronized同步的线程不可被中断***

* wait和notify方法详解

  * wait方法的这三个重载方法都将调用wait(long timeout)这个方法,wait()方法等价于wait(0),0代表用不超时
  * Object的wait方法会导致当前线程进入阻塞,知道有其他线程关掉用了Object的notify或者notifyAll方法才能将其唤醒,或者阻塞时间到达了timeout时间而自动唤醒
  * wait方法必须拥有该对象的monitor,也就是wait方法必须在同步方法中使用
  * 当前线程执行了该对象的wait方法之后,将会放弃对该monitor的所有权并且进入与该对象关联的wait set中,也就是说一旦线程执行了某个Object的wait方法之后,它就会释放对该对象monitor的所有权,其他贤臣哥也会有机会继续争抢该monitor的所有权

  > notify

  * 唤醒单个正在执行该对象wait方法的线程
  * 如果有某个线程由于执行该对象的wait方法而进入阻塞则会被唤醒,如果没有则会忽略
  * 被唤醒的线程需要重新获取对该对象所关联monitor的lock才能继续执行

* 关于wait和notify的注意事项

  * wait方法是可中断方法,这也就意味着,当前线程一旦调用了wait方法进入阻塞状态,其他线程是可以使用interrupt方法将其打断的
  * 线程执行了某个对象的wait方法以后,会加入与之对应的wait set中,每一个对象的monitor都有与之关联的wait set
  * 当线程进入wait set之后,notify方法可以将其唤醒,也就是从wait set中弹出,同时终端wait中的线程也会将其唤醒
  * 必须在同步方法中使用wait和notify方法,因为执行wait和notify的前提条件是必须持有同步方法的monitor的所有权,运行下面任何一个方法都会抛出非法的monitor状态异常IllegalMonitorStateException
  * 同步代码monitor必须与执行wait notify方法的对象一直,简单地说就是用哪个对象的monitor进行同步,就只能用哪个对象进行wait和notify操作

* wait和sleep

  从表面上看,wait和sleep方法都可以是当前线程进入阻塞状态,但是两者之间存在着本质的区别:

  * wait和sleep方法都可以使线程进入阻塞状态
  * wait和sleep方法均是可中断方法,被中断后都会收到中断异常
  * wait是Object的方法,而sleep是Thread特有的方法
  * ***wait方法的执行必须在同步方法中进行,而sleep不需要***
  * ***线程在同步方法中执行sleep方法时,并不会释放monitor的锁,而wait方法则会释放monitor的锁***
  * sleep方法短暂休眠之后会主动退出阻塞,而wait方法(没有指定wait时间)则需要被其他线程中断后才能退出阻塞

* ThreadGroup与Thread

  在Java程序中,默认情况下,新的线程都会被加入到main线程所在的group中,main线程的group名字同线程名.

  ***无论如何,线程都会被加入某个ThreadGroup之中.***

  > ### 复制Thread数组
  >
  > ```java
  > public int enumerate(Thread[] list)
  > public int enumerate(Thread[] list,boolean recurse)
  > ```
  >
  > * 上述两个方法,会将ThreadGroup中的active线程全部复制到Thread数组中,其中recurse参数如果为true,则该方法会将所有**子group**中的active线程都递归到Thread数组中,enumerate(Thread[] list)实际上等价于enumerate(Thread[],true),上面两个方法都调用了ThreadGroup的私有方法enumerate():
  >
  > ```java
  > private int enumerate(Thread[] list,int n,boolean recurse){}
  > ```
  >
  > > ### note
  > >
  > > 1. enumerate方法获取的线程仅仅是个预估值,并不能百分之百的保证当前group的活跃线程,比如在调用复制之后,某个线程结束了声明周期或者新的线程加入了进来,都会导致数据的不准确
  > > 2. enumerate方法的返回值int相较Thread[]的长度更为真实,比如定义了数组长度的Thread数组,那么enumerate方法仅仅会将当前活跃的thread分别放入数组中,而返回值int则代表真实的数量,并非Thread数组的长度

* ThreadGroup操作

  ThreadGroup并不能提供对线程的管理,ThreadGroup的主要功能是对线程进行组织

  * ThreadGroup的destory

    destroy用于销毁ThreadGroup,该方法只是针对一个没有任何active线程的group进行一次destroy标记,调用更该方法的直接结果是在父group中将自己移除

    > 销毁ThreadGroup及其子ThreadGroup,在该ThreadGroup中所有的线程必须是空的,也就是说ThreadGroup或者子ThreadGroup所有的线程都已经停止运行,如果有Active线程存在,调用destroy方法则会抛出异常.

  * ThreadGroup的interrupt

    interrupt一个ThreadGroup会导致该group中所有的active线程都被interrupt,也就是说该group中每一个线程的interrupt标识都被设置了

  * 守护ThreadGroup

    线程可以设置为守护线程,ThreadGroup也可以设置为守护ThreadGroup,但是若将一个ThreadGroup设置为daemon,也并不会影响线程的daemon属性,如果一个ThreadGroup的daemon被设置为true,那么在group中没有任何active线程的时候该group将自动destroy

  ThreadGroup并不是用来管理Thread的,而是针对Thread的一个组织

* 获取线程运行时异常

  线程在执行单元中是不允许抛出checked异常的,而且线程运行在自己的上下文中,派生它的线程将无法直接获得它运行中出现的异常信息.对此,Java为我们提供了一个UncaughtExceptionHandler接口,当线程在运行过程中出现异常是,会回调UncaughtExceptionHandler接口,从而得知是哪个线程在运行时出错,以及出现了什么样的错误

  > 在没有向线程注入UncaughtExceptionHandler回调接口的情况下,线程若出现了异常,通过源码分析:
  >
  > ```java
  > public UncaughtExceptionHandler getUncaughtExceptionHandler(){
  >     return uncaughtException != null? uncaughtExceptionHandler : group;
  > }
  > ```
  >
  > getUncaughtExceptionHandler方法首先会判断当前线程是否设置了Handler,如果有则执行自己的UncaughtException方法,否则就到所在的ThreadGroup中获取,ThreadGroup同样也实现了UncaughtExceptionHandler接口:
  >
  > > 1. 该ThreadGroup如果有父ThreadGroup,则直接调用父ThreadGroup的uncaughtException方法
  > > 2. 如果设置了全局默认的UncaughtExceptionHandler,则调用uncaughtException方法
  > > 3. 若既没有父ThreadGroup,也没有设置全局默认的UncaughtExceptionHandler,则会直接将异常的堆栈信息定向到System.err中

* 注入钩子线程

  1. Hook线程介绍

  JVM进程的退出时由于JVM进程中没有活跃的非守护线程,或者收到了系统中断信号,向JVM程序注入了一个Hook线程,在JVM进程退出的时候,Hook线程会启动执行,通过Runtime可以为JVM注入多个Hook线程

  2. Hook线程实战

  为了防止某个程序被重复启动,在进程启动时会创建一个lock文件,进程收到中断信号的时候会删除这个lock文件,我们在mysql服务器,zookeeper,kafka等系统中都能看到lock文件的存在

  3. Hook线程应用场景以及注意事项
     * Hook线程只有在收到退出信号的时候会被执行,如果在kill的时候使用了参数**-9**,那么Hook线程不会得到执行,进程将会立即退出,因此.lock文件将得不到清理
     * Hook线程中也可以执行一些资源释放的工作,比如关闭文件句柄,socket链接,数据库connection等
     * 尽量不要在Hook线程中执行一些耗时非常长的操作,因为其会导致程序迟迟不能退出

* 线程池

  > Thread是一个重量级的资源,创建,启动以及销毁都是比较耗费系统资源的,因此对线程的重复利用是一种非常好的程序设计习惯,加之系统中可创建的线程数量是有限的,线程数量和系统性能是一中抛物线的关系,也就是说当线程数量达到某个数值的时候,性能反倒会降低很多,因此对线程的管理,尤其是数量的控制更能直接决定程序的性能

  * ### 线程池原理 ###

    一个完整的线程池应该具备如下要素:

    1. 任务队列:用于缓存提交的任务
    2. 线程数量管理功能:一个线程池必须能够很好地管理和控制线程数量,可通过如下三个参数来实现,比如创建线程池时初试的线程数量 ***init*** ;线程池自动扩充时最大的线程数量 ***max*** ;在线程池空闲时需要释放线程但是也要维护一定数量的活跃数量或者核心数量 ***core*** ;***三者之间的关系是 init<=core<=max***
    3. 任务拒绝策略:如果线程数量已达到上限且任务队列已满,则需要有相应的拒绝策略来通知任务提交者
    4. 线程工厂:主要用于个性化定制线程,比如将线程设置为守护线程以及设置线程名称等
    5. QueueSize:任务队列主要存放提交的Runnable,但是为了防止内存溢出,需要有***limit***数量对其进行控制
    6. Keepedalive时间:该时间主要决定线程各个参数自动维护的时间间隔

  * 自动维护线程的代码块是同步代码块,主要是为了阻止在线程维护过程中线程池销毁引起的数据不一致问题

  * 线程池的销毁同样需要同步机制的保护,主要是为了防止与线程池本身的维护线程引起数据冲突

* 类的加载过程

  > ClassLoader的主要职责就是负责加载各种class文件到JVM中,ClassLoader是一个抽象的class,给定一个class的二进制文件名,ClassLoader会尝试加载并且在JVM中生成构成这个类的各个数据结构,然后使其分布在JVM对应的内存区域中.

  * 类的加载过程

    * 加载阶段:主要负责查找并且加载类的二进制数据文件,其实就是class文件.
    * 连接阶段:连接阶段所做的工作比较多,细分的话还可以分为如下三个阶段:
      * 验证:主要是确保文件的正确性,比如class的版本,class文件的魔术因子是否正确
      * 准备:为类的静态变量分配内存,并且为其初始化默认值
      * 解析:把类中的符号引用转换为直接引用
    * 初始化阶段:为类的静态变量赋予正确的初试值(代码编写阶段给定的值)

  * 类的主动使用和被动使用

    JVM规范了以下6种主动使用类的场景:

    1. 通过new关键字会导致类的初始化:它肯定会导致类的加载并且最终初始化
    2. 访问类的静态变量,包括读取和更新会导致类的初始化
    3. 访问类的静态方法,会导致类的初始化
    4. 对某个类进行反射操作,会导致类的初始化
    5. 初始化子类会导致父类的初始化(通过子类使用父类的静态变量只会导致父类的初始化,子类不会被初始化)
    6. 启动类:也就是执行main函数所在的类会导致该类的初始化

    除了这6种情况,其余的都被称为被动使用,不会导致类的加载和初始化

    1. 构造某个类的数组时不会导致该类的初始化
    2. 引用类的静态常量不会导致类的初始化(若变量计算复杂,也需要初始化)

  * 类的加载阶段

    类的加载就是将class文件中的二进制数据读取到内存之中,然后将该字节流所代表的静态存储结构转换为方法区中运行时的数据结构,并且在堆内存中生成一个该类的java.lang.Class对象,作为访问方法区数据结构的入口

    ![image-20181119114710305](/Users/admin/Blog/类加载分布.png)

    类加载的最终产物就是堆内存中的class对象,对同一个ClassLoader来讲,不管某个类被加载了多少次,对应到堆内存中的class对象始终是同一个.虚拟机规范中指出了类的加载是通过一个全限定名(包名+类名)来获取二进制数据流:

    * 运行时动态生成,比如通过开源的ASM包可以生成一些class,或者通过动态代理java.lang.Proxy也可以生成代理类的二进制字节流
    * 通过网络获取,比如很早之前的Applet小程序,以及RMI动态发布等
    * 通过读取zip文件获得类的二进制字节流,比如jar,war
    * 将类的二进制数据存储在数据库的BLOB字段类型中
    * 运行时生成class文件,并且动态加载,比如使用thrift,AVRO等都是可以在运行时将某个Schema文件生成对应的若干个class文件,然后再进行加载

  * 类的连接阶段

    类的连接阶段可以细分为三个小的过程,分别是验证,准备和解析

    1. 验证

       * 验证文件格式
       * 元数据的验证
       * 字节码验证
       * 符号引用验证

    2. 准备

       当一个class的字节流通过了所有的验证过程之后,就开始为该对象的类变量,也就是静态变量,分配内存并且设置初始值了,***类变量的内存会被分配到方法区中,不同于实例变量会被分配到堆内存之中***

       所谓设置初始值,其实就是为相应的类变量给定一个相关类型在没有被设置值时的默认值.(final修饰的静态变量(可以直接计算得出结果)不会导致累的初始化,是一种被动引用,不存在连接阶段,更严谨的解释为:***final static int 吧b = 10 在类的编译阶段javac会将其value生成一个ConstantValue属性,直接赋予10***)

    3. 解析

       解析就是在常量池中寻找类,接口,字段和方法的符号引用,并且为这些符号引用替换成直接引用的过程

       虚拟机规范规定了,在anewarray / checkcast / getfield / getstatic / instanceof / invokeinterface / invokespecial / invokestatic  / invokevirtual / multianewarray / new / putfield / putstatic这13个操作符号引用的字节码指令之前,必须对所有的符号提前进行解析

       解析过程主要是针对类接口,字段,类方法和接口方法这四类进行的,分别对应到常量池中的CONSTANT_Class_info,CONSTANT_Fieldref_info,Constant_Methodref_info和Constant_InterfaceMethodred_info这四种类型常量

       1. 类接口解析
       2. 字段的解析
       3. 类方法的解析  
       4. 接口方法的写解析

  * 类的初始化阶段

    类的初始化阶段是整个类加载过程中的最后一个阶段,在初始化阶段做的最主要的一件事情就是执行<clinit>()方法的过程(clinit是**class initialize**前面几个字母的简写)在<clinit>()方法中的所有类变量都会被赋予正确的值,也就是在程序编写的时候指定的值

    <clinit>()方法是在编译阶段生成的,也就是说它已经包含在了class文件中了,<clinit>()中包含了所有***类变量的赋值动作和静态语句块的执行代码***,编译器收集的顺序是由***执行语句在源文件中的出现顺序***所决定的(<clinit>()是能够保证顺序性的).另外需要注意的一点是,***静态语句块只能对后面的静态变量进行赋值,但是不能对其进行访问***

    另外<clinit>()方法与类的构造函数有所不同,它不需要显式的调用父类的构造器,**虚拟机会保证父类的<clinit>()方法最先执行**,因此***父类的静态变量总是能够得到优先赋值***

    虽然说Java编译器会帮助class生成<clinit>()方法,但是该方法并不意味着总是会生成,比如***某个类中既没有静态代码块,也没有静态变量,那么他就没有生成<clinit>()方法的必要了***,接口中同样也是如此,***由于接口天生不能定义静态代码块,因此只有当接口中有变量的初始化操作时才会发生<clinit>()方法***.

* JVM类加载器

  类加载器就是负责类的加载职责,对于任意一个class,都需要由加载它的类加载器和这个类本身确立其在JVM中的唯一性,这也就是运行时包.

  ***任何一个对象的class在JVM中只存在唯一的一份,比如String.class,Object.class在堆内存以及方法区中肯定是唯一的,但是不能绝对的理解为我们自定义的类在JVM中同样也是这样***

  * JVM内置三大类加载器

    JVM为我们提供了三大内置的类加载器,不同的类加载器负责将不同的类加载到JVM内存之中,并且他们之间严格遵守着父委托的机制

    1. 根类加载器

       根加载器又称为Bootstrap类加载器,该类加载器是最为顶层的加载器,其没有任何父加载器,它是由C++编写的,主要负责虚拟机核心类库的加载,比如整个java.lang包都是由根加载器所加载的,可以通过***-Xbootclasspath***来指定根加载器的路径,也可以通过系统属性来得知JVM的根加载器都加载了哪些资源

    2. 扩展类加载器

       扩展类加载器的父加载器是根加载器,它主要用于加载JAVA_HOME下的jre\lib\ext子目录里面的类库,扩展类加载器是由纯Java语言实现的,他是*java.lang.URLClassLoader*的子类,它的完整类名是**sun.misc.Launcher$ExtClassLoader**.扩展类加载器所加载的类库可以通过系统属性java.ext.dirs获得

    3. 系统类加载器

       系统类加载器是一种常见的类加载器,其负责加载classpath下的类库资源,我们在进行项目开发的时候引入的第三方jar包,系统类加载器的父加载器是扩展类加载器,同时它也是自定义类加载器的默认父加载器,系统类加载器的加载路径一般通过-classpath或者-cp指定,同样也可以通过系统属性java.class.path进行获取

    Java除了提供上述的三大类内置类加载器之外,还允许开发人员进行类加载器的扩展,也就是自定义类加载器,很多开源项目借助于自定义类加载器开发除了很多伟大的系统,比如OSGI,Tomcat的容器隔离等

  * 自定义类加载器

    所有的自定义类加载器都是ClassLoader的直接子类或者间接子类,java.lang.ClassLoader是一个抽象类,它里面并没有抽象方法,但是有findClass方法,务必实现该方法,否则将会抛出Class找不到的异常

    

    ```java
    protected Class<?> findClass(String name) throws ClassNotFoundException{
        throw new ClassNotFoundException(name);
    }
    ```

  * 双亲委托机制

    当一个类加载器被调用了loadClass之后,它并不会直接将其加载,而是先交给当前类加载器的父加载器尝试加载知道最顶层的父加载器,然后再依次向下进行加载

    1. 破坏双亲委托机制

       方法一:绕过系统类加载器,直接将扩展类加载器作为类的父加载器.

       ​	首先我们通过MyClassLoaderTest.class获取系统类加载器,然后再获取系统类加载器的父类加载器中的扩展类加载器,使其成为MyClassLoader的父类加载器,这样一来,根加载器和扩展类加载器都无法对目录中的类文件进行加载,自然而然就交给了MyClassLoader对HelloWorld进行加载了

       方法二:构造MyClassLoader的时候指定其父类加载器为null

       根据源码分析,当前类在没有父类加载器的情况下,会直接使用根加载器对该类进行加载,很显然,HelloWorld在根加载器的加载路径下是无法找到的,那么它自然而然地就交给当前类加载器进行加载了

       这两种方案,采取的都是绕过ApplicationClassLoader的方式去实现的,并没有避免一层一层的委托,那么有什么办法可以绕过这种双亲委托的模型呢?

       JDK提供的双亲委托机制并非是一个强制性的模型,程序开发人员是可以对其进行灵活发挥破坏这种委托机制的,

       > 热部署:热部署首先要卸载掉加载该模块所有Class的类加载器,卸载类加载器会导致所有类的卸载,我们无法对JVM三大内置加载器进行卸载,我们只有通过控制自定义类加载器才能做到这一点

    2. 类加载器命名空间,运行时包,类的卸载等

       1. 类加载器命名空间

       ​	每一个类加载器实例都有各自的命名空间,命名空间是由该加载器及其所有父加载器所构成的,因此在每个类加载器中同一个class都是独一无二的,不论load多少次,都会发现它们始终是同一份class对象

       ​	但是,使用不同的类加载器,或者同一个类加载器的不同实例,去加载同一个class,则会在堆内存和方法区产生多个class对象

       ​	同一个class实例只能在JVM中存在一份这样的说法是不够严谨的,更准确的说法应该是***同一个class实例在同一个类加载器命名空间之下是唯一的***

       2. 运行时包

          我们在编写代码的时候通常会给一个类指定一个包名,包的作用是为了组织类,防止不同包下同样名称的class引起冲突,还能起到封装的作用,包名和类名构成了类的全限定名称.在JVM运行时class会有一个运行时包,运行时的包是由类加载器的命名空间和类的全限定名称共同组成的

          这样做的好处同样是处于安全和封装的考虑,在java.lang.String中存在仅包可见的方法*void getChars(char[] var1,int var2)*,java.lang包以外的class是无法直接对其访问的.假设用户想自定义一个类java.lang.HackString,并且有自定义的类加载器进行加载,尝试访问getChars方法,由于*java.lang.HackString*和*java.lang.String*是由不同的类加载器进行加载的,它们拥有各自不同的运行时包,因此HackString是无法访问java.lang.String的包可见方法以及成员变量的

       3. 初始类加载器

          由于运行时包的存在,JVM规定了不同的运行时包下的类彼此之间是不可以进行访问的,那么问题来了,为什么我们可以在开发的程序中可以访问java.lang包下的类呢?

          每一个类在经过ClassLoader的加载之后,在虚拟机中都会有对应的Class实例,如果某个类C被类加载器CL加载,那么CL就被称为C的***初始类加载器***.JVM为每一个类加载器维护了一个列表,该列表中记录了将该类加载器作为初始类加载器的所有class,在加载一个类时,JVM使用这些列表来判断该类是否已经被加载过了,是否需要首次加载

          根据JVM规范的规定,在类的加载过程中,所有参与的类加载器,即使没有亲自加载过该类,也都会被标识为该类的初始类加载器,比如java.lang.String首先经过了BrokerDelegateClassLoader类加载器,依次又经过了系统类加载器,扩展类加载器,根类加载器,这些类加载器都是java.lang.String的初始类加载器,JVM会在每一个类加载器维护的列表中添加该class类型

       4. 类的卸载

          在JVM的启动过程中,JVM会加载很多的类,在运行期间同样也会加载很多的类,比如用自定义的类加载器进行类的加载,或者像Apache Drools框架一样会在每一个DSL文件解析成功之后生成相应的类文件.关于JVM在运行期间到底加载了多少class,可以在启动JVM时指定***-verbose:class***参数观察得到,我们知道某个对象在堆内存中如果没有其他地方引用则会在垃圾回收器线程进行GC的时候被回收掉,那么该对象在堆内存中的**Class对象以及Class在方法区中的数据结构**何时被回收呢?

          JVM规定了一个Class只有在满足下面三个条件的时候才会被GC回收,也就是**类被卸载**:

          * 该类所有的实例都已经被GC,
          * 加载该类的ClassLoader实例被回收
          * 该类的class实例没有在其他地方被引用

* 线程上下文类加载器

  * 为什么需要线程上下文类加载器

    根据Thread类的文档会发现线程上下文方法是从JDK1.2开始引入的,**getContextClassLoader()和setContextClassLoader(ClassLoader c1)**分别用于获取和设置当前线程的上下文类加载器,如果当前线程没有设置上下文类加载器,那么它将和父线程保持同样的类加载器,站在开发者的角度,其他线程都是由Main线程,也就是main函数所在的线程派生的,它是其他线程的父线程或者祖父线程.

    JDK的核心库中提供了很多SPI(Service Provider Interface),常见的SPI包括JDBC,JCE,JNDI,JAXP和JBI等,JDK之规定了这些接口之间的逻辑关系,但不提供具体的实现,具体的实现需要由第三方厂商来提供,这样做的好处是JDBC提供了高度抽象,应用程序则只需要面向接口编程即可,不用关心各大数据库厂商的具体实现,但问题在于java.lang.sql中的所有接口都由JDK提供,加载这些接口的类加载器是根加载器,第三方厂商提供的类库驱动则是由系统类加载器加载的,由于JVM类加载器的双亲委托机制,比如Connections,Statement,RowSet等皆由根加载器加载,第三方的JDBC驱动包中的实现不会被加载.

* volatile关键字

  volatile关键字只能修饰类变量和实例变量,对于方法参数,局部变量以及实例常量,类常量都不能进行修饰

  > Cache的出现是为了解决CPU直接访问内存效率低下问题的,程序在运行的过程中,会将运算所需要的数据从主存复制一份到CPU Cache中,这样CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入,当运算结束之后,再将CPU Cache中的最新数据刷新到主内存当中,CPU通过直接访问Cache的方式替代直接访问主存的方式极大地提高了CPU的吞吐能力,

  * CPU缓存一致性问题

    由于缓存的出现,极大地提高了CPU的吞吐能力,但是同时也引入了缓存不一致的问题,比如i++这个操作,在程序的运行过程中,首先需要将主存中的数据复制一份存放到CPU Cache中 ,那么CPU寄存器在进行数值计算的时候就直接到Cache中读取和写入,当整个过程运算结束之后再将Cache中的数据刷新到主存中

    i++在单线程的情况下不会出现任何问题,但是在多线程的情况下就会有问题,每个线程都有自己的工作内存(本地内存,对应于CPU中的Cache),变量i会在多个线程的本地内存中都存在一个副本,如果同时有两个线程执行i++操作,假设i的初始值为0,每一个线程都从主内存中获取i的值存入CPU Cache中,然后经过计算再写入主内存中,很有可能i在经过了两次自增之后结果还是1,这就是典型的缓存不一致问题.

    **为了解决缓存不一致性问题,通常主流的解决方法有如下两种:**

    1. ***通过总线加锁的方式***
    2. ***通过缓存一致性协议***

    第一种方式常见于早期的CPU当中,而且是一种悲观的实现方式,CPU和其他组件的通信都是通过总线(数据总线,控制总线,地址总线)来进行的,如果采用总线加锁的方式,则会阻塞其他CPU对其他组件的访问,*从而使得只有一个CPU(抢到总线锁)能够访问这个变量的内存(效率低下)*

    在缓存一致性协议中最为出名的是Intel的MESI协议,MESI协议保证了每一个缓存中使用的共享变量副本都是一致的,它的大致思想,**当CPU在操作Cache中的数据时,如果发现该变量是一个共享变量,也就是说在其他的CPU Cache中也存在一个副本,那么进行如下操作:**

    1. ***读取操作,不做任何处理,只是将Cache中的数据读取到寄存器***
    2. ***写入操作,发出信号通知其他CPU将该变量的Cache line置为无效状态,其他CPU在进行变量读取的时候不得不到主内存中再次获取***

  * Java内存模型(Java Memory Mode,JMM)

    Java的内存模型决定了一个线程对共享变量的写入何时对其他线程可见,Java内存模型定义了线程和主内存之间的抽象关系,具体如下:

    1. 共享变量存储于主内存之中,每个线程都可以访问
    2. 每个线程都有私有的工作内存或者称为本地内存
    3. 工作内存只存储该线程对共享变量的副本
    4. 线程不能直接操作主内存,只有先操作了工作内存之后才能写入主内存
    5. 工作内存和Java内存模型一样也是一个抽象的概念,它其实并不存在,它涵盖了缓存,寄存器,编译器优化以及硬件等

  * 并发编程的三个重要特性

    * 原子性

      **所谓原子性是指在一次的操作或者多次操作中,要么所有的操作全部得到了执行并且不会受到任何因素的干扰而中断,要么所有的操作都不执行.**

      > 注意:两个原子性的操作结合在一起未必还是原子性的,比如i++(其中get i,i+1,set i=x 三者皆是原子性操作,但是不代表i++就是原子性操作)
      >
      > **volatile关键字不保证数据的原子性,synchronized关键字保证,自JKD1.5版本起,其提供的原子类型变量也可以保证原子性.**

    * 可见性

      可见性是指,当一个线程对共享变量进行了修改,那么另外的线程可以立即看到修改后的最新值

    * 有序性

      所谓有序性是指程序代码在执行过程中的先后顺序,由于Java在编译器以及运行期的优化,导致了代码的执行顺序未必就是开发者编写代码时的顺序

  * JMM如何保证三大特性

    1. JMM与原子性

       在Java语言中,对基本数据类型的变量读取赋值操作都是原子性的,对引用类型的变量读取和赋值操作也是原子性的,因此诸如此类的操作是不可被中断的,要么执行,要么不执行

       > 1. 多个原子性的操作在一起就不再试原子性操作了
       > 2. 简单的读取与赋值操作是原子性的,将一个变量赋给另外一个变量的操作不是原子性的
       > 3. Java内存模型(JMM)只保证了基本读取和赋值的原子性操作,其他的均不保证,如果想要使得某些代码片段具备原子性,需要使用关键字synchronized,或者JUC中的lock,如果想要使得int等类型自增操作具备原子性,可以使用JUC包下的原子封装类型 java.util.concurrent.atomic.*
       >
       > ***总结:volatile关键字不具备保证原子性的语义.***

    2. JMM与可见性

       Java提供了一下三种方式来保证可见性:

       1. 使用关键字volatile,当一个变量被volatile关键字修饰时,对于共享资源的读操作会直接在主内存中进行(当然也会缓存到工作内存中,当其他线程对该共享资源进行了修改,则会导致当前线程在工作内存中的共享资源失效,所以必须从主内存中再次获取),对于共享资源的写操作当然是先要修改工作内存,但是修改结束后会立刻将其刷新到主内存中

       2. 通过synchronized关键字能够保证可见性,synchronized关键字能够保证同一时刻只有一个线程获得锁,然后执行同步方法,并且还会确保在锁释放之前,会将对变量的修改刷新到主内存当中

       3. 通过JUC提供的显式锁Lock也能够保证可见性,Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法,并且会确保在锁释放(Lock的unlock方法)之前会将对变量的修改刷新到主内存当中

          > ***总结:volatile关键字具有保证可见性的语义.***

    3. JMM与有序性

       在Java的内存模型中,允许编译器和处理器对指令进行重排序,在单线程的情况下,重排序并不会引起什么问题,但是在多线程的情况下,重排序会影响到程序的正确运行,Java提供了三种保证有序性的方式:

       1. 使用volatile关键字来保证有序性
       2. 使用synchronized关键字来保证有序性
       3. 使用显式锁Lock来保证有序性

       后两者采用了同步的机制,同步代码在执行的时候与在单线程情况下一样自然能够保证顺序性(最终结果的顺序性)

       **Happens-before原则**:

       * 程序次序规则:在一个线程内,代码按照编写时的次序执行,编写在后面的操作发生于编写在前面的操作之后

         > 程序按照编写的顺序来执行,但是虚拟机还是可能会对程序代码的指令进行重排序,只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可

       * 锁定规则:一个unlock操作要先行发生对同一个锁的lock操作

         > 无论是在单线程还是多线程的环境下,如果同一个锁是锁定状态,那么必须先对其执行释放操作之后才能继续进行lock操作

       * volatile变量规则:对一个变量的写操作要早于对这个变量之后的读操作

         > 如果一个变量使用volatile关键字修饰,一个线程对它进行读操作,一个线程对它进行写操作,呢么写入操作肯定要先行发生于读操作

       * 传递规则:如果操作先于操作B,而操作B又先于操作C,则可以得出操作A肯定要先于操作C

       * 线程启动规则:Thread对象的start()方法先行发生于对该线程的任何动作

       * 线程中断规则:对线程进行interrupt()方法肯定要优先于捕获到中断信号

         > 指如果线程收到了中断信号,那么在此之前势必要有interrupt()

       * 线程的终结规则:线程中所有的操作都要先行发生于线程的终止检测,通俗地讲,线程的任务执行,逻辑单元执行肯定要发生于线程死亡之前

       * 对象的终结规则:一个对象初始化的完成先行发生于finalize()方法之前

       > ***总结:volatile关键字具有保证顺序性的语义.***

  * volatile关键字深入解析

    被volatile修饰的实例变量或者类变量具备如下两层语义:

    1. 保证了不同线程之间对共享变量操作时的可见性,也就是说当一个线程修改volatile修饰的变量,另外一个线程会立即看到最新的值
    2. 禁止对指令进行重排序操作

* 7种单例模式的设计

  * 饿汉式

    饿汉式的关键在于instance作为类变量并且直接得到了初始化,如果主动使用Singleton类,那么instance实例将会直接完成创建,包括其中的实例变量都会的到初始化

    instance作为类变量在类初始化的过程中会被收集进<clinit>()方法中,该方法能够百分之百地保证同步,也就是说instance在多线程的情况下不可能被实例化两次,但是instance被ClassLoader加载后可能很长一段时间才被使用,那就意味着instance实例所开辟的堆内存会驻留更久的时间

    ***如果一个类中的成员属性比较少,且占用的内存资源不多,饿汉的方式未尝不可,相反,如果一个类中的成员都是比较重的资源,那么这种方式就会有些不妥***

    > 总结:饿汉式的单例设计模式可保证多个线程下的唯一实例,getInstance()方法性能也比较高,但是无法进行懒加载

  * 懒汉式

    所谓懒汉式就是在使用类实例的时候再去创建(用时创建),这样就可以避免类在初始化时提前创建

    ***多线程环境下,会导致instance被实例化一次以上,并不能保证单例的唯一性***

  * 懒汉式+同步方法

    懒汉式的方式可以保证实例的懒加载,但无法保证实例的唯一性,根据之前的内容,在多线程的情况下,instance又称为共享数据(数据),当多个线程对其访问使用时,需要保证数据的同步性

    ***采用懒汉式+数据同步的方式既满足了懒加载又能够百分之百地保证instance实例的唯一性,但是synchronized关键字天生的排他性导致了getInstance方法只能在同一时刻被一个线程所访问,性能低下***

  * Double-Check

    Double-Check是一种比较聪明的设计方式,他提供了而一种高效的数据同步策略,那就是首次初始化时加锁,之后则允许多个线程同时进行getInstance方法的调用来获得类的实例

    Double-Check提供了高效的数据同步策略,可以允许多个线程同时对getInstance进行访问,但是这种方式在多线程的情况下有可能引起空指针异常

  * Volatile+Double-Check

    Double=Check有可能会引起类成员变量的实例化,这一切均是由于JVM在运行时置零重排序所导致的,而volatile关键字则可以防止这种重排序的发生,因此代码稍作修改即可满足多线程下的单例,懒加载以及获取实例的高效性

    ```java
    private volatile static Singleton instance = null;
    ```

  * Holder方式

    Holder方式是借助了类加载的特点

    Singleton类中并没有instance的静态成员,而是将其放到了静态内部类Holder中,因此Singleton类的初始化过程中并不会创建Singleton的实例,Holder类中定义了Singleton的静态变量,并且直接进行了实例化,当Holder被主动引用的时候则会创建Singleton的实例,Singleton实例的创建过程在Java程序编译时期收集至<clinit>()方法中,该方法又是同步方法,同步方法可以保证内存的可见性,JVM指令的顺序性和原子性

  * 枚举方式

    枚举类型不允许被继承,同样是线程安全的且只能被实例化一次,但是枚举类型不能够懒加载,对Singleton主动使用,比如调用其中的静态方法则Instance会立即得到实例化

* 监控任务的声明周期

  * 当观察者模式遇到Thread

    当某个对象发生状态改变需要通知第三方的时候,观察者模式就特别适合胜任这样的工作.观察者模式需要有事件源,也就是引发状态改变的源头,很明显Thread负责执行任务的逻辑单元,它最清楚整个过程的始末周期,而事件的接受者则是通知接受者一方,严格意义上的观察者模式是需要Observer的集合的,但是这里不需要完全遵守这样的规则,只需将执行任务的每一个阶段都通知给观察者即可
