# MySql

## MySQL架构与历史

### 优化与执行

MySQL会解析查询,并创建内部数据结构(***解析树***),然后对其进行各种优化,包括重写查询,决定表的读取顺序,以及选择合适的索引等,用户可以通过特殊的关键字提示(hint)优化器,影响它的决策过程.也可以请求优化器解释(explain)优化过程的各个因素,使用户可以知道服务器是如何进行优化决策的,并提供一个参考基准,便于用户重构查询和schema,修改相关配置,使应用尽可能高效运行.

优化器并不关心表使用的是什么存储引擎,但存储引擎对于优化查询是有影响的,优化器会请求存储引擎提供容量或某个具体操作的开销信息,以及表数据的统计信息等.

对于SELECT语句,在解析查询之前,服务器会先检查***查询缓存***(*Query Cache*),如果能够在其中找到对应的查询,服务器就不必再执行查询解析,优化和执行的整个过程,而是直接返回查询缓存中的结果集.

### 读写锁

在处理并发读或者写时,可以通过**实现一个由两种类型的锁组成的锁系统**来解决问题.这两种类型的锁通常被称为***共享锁***(*shared lock*)和***排他锁***(*exclusive lock*),也叫***读锁***(*read lock*)和***写锁***(*write lock*).

描述一下锁的概念如下:**读锁是共享的,或者说是互相不阻塞的,多个客户在同一时刻可以同时读取同一个资源,而互不干扰,写锁则是排他的,也就是说一个写锁会阻塞其他的写锁和读锁,这是出于安全策略的考虑,只有这样,才能确保在给定的时间里,只有一个用户能执行写入,并防止其他用户读取正在写入的同一资源**

### 锁粒度

一种提高共享资源并发性的方式就是让锁定对象更有选择性.尽量只锁定需要修改的部分数据,而不是所有的资源.更理想的方式是:*针对会修改的数据片进行精确的锁定*.**任何时候,在给定的资源上,锁定的数据量越少,则系统的并发程度越高,只要相互之间不发生冲突即可**.

所谓的锁策略,就是在锁的开销和数据的安全性之间寻求平衡,这种平衡当然也会影响到性能.大多数商业数据库系统没有提供更多的选择,一般都是在表上施加行级锁(*row-level lock*).

#### 表锁(*table lock*)

表锁是MySQL中最近本的锁策略,并且是开销最小的策略.表锁非常类似于前文描述的邮箱加锁机制:**它会锁定整张表,一个用户在对表进行写操作(插入,删除,更新等)前,需要先获得写锁,这回阻塞其他用户对该表的所有读写操作.只有没有写锁时,其他读取的用户才能获得读锁,读锁之间是不互相阻塞的**.

*在特定的场景中,表锁也可能有良好的性能.例如:READ LOCKL表锁支持某些类型的并发写操作;另外,写锁也比读锁有更高的优先级,因此一个写锁请求可能会被插入到读锁队列的前面,(写锁可以插入到锁队列中读锁的前面,反之读锁则不能插入到写锁的前面)*.

尽管存储引擎可以管理自己的锁,MySQL本身还是会使用各种有效的表锁来实现不同的目的.例如,*服务器会为诸如ALTER TABLE之类的语句使用表锁,而忽略存储引擎的锁机制*.

#### 行级锁(*row lock*)

行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销).众所周知,在InnoDB和XtraDB,以及其他一些存储引擎中实现了行级锁.*行级锁只在存储引擎层实现,而MySQL服务器层没有实现,服务器层完全不了解存储引擎中的锁实现*.

### 事务

**ACID表示原子性(*atomicity*),一致性(*consistency*),隔离性(*isolation*)和持久性(*durability*),一个运行良好的事务处理系统,必须具备这些标准特征.**

> 原子性:一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚,对于一个事务来说,不可能只执行其中的一部分操作,这就是事务的原子性.
>
> 一致性:数据库总是从一个一致性的状态转换到另外一个一致性的状态.(数据不会无故增加或减少)
>
> 隔离性:**通常来说**,一个事务所做的修改在最终提交之前,对其他事务是不可见的.
>
> 持久性:一旦事务提交,则其所做的修改就会永久保存到数据库中.此时即使系统崩溃,修改的数据也不会丢失.持久性是个有点模糊的概念,因为实际上持久性也分很多不同的级别.有些持久性策略能够提供非常强的安全保障,而有些则未必,而且不可能又能做到100%的持久性保证的策略.

#### 隔离级别

四种隔离级别:

**READ UNCOMMITTED(未提交读)**:

​	在READ UNCOMMITTED级别,事务中的修改,即使没有提交,对其他事务也都是可见的.事务可以读取未提交的数据,这也被称为**脏读**(*Dirty Read*).除非真的有非常必要的理由,在实际应用中一般很少用.

**READ COMMITTED(提交读)**:

​	大多数数据库系统的默认隔离级别都是READ COMMITTED(但MySQL不是).READ COMMITTED满足前面提到的隔离性的简单定义:一个事务开始时,只能"看见"已经提交的事务所做的修改.换句话说,一个事务从开始直到提交之前,所做的任何修改对其他事务都是不可见的.这个级别有时候也叫做**不可重复读**(*nonrepeatable read*),因为两次执行同样的查询,可能会得到不一样的结果.

**REPEATABLE READ(可重复读)**:

​	REPEATABLE READ解决了脏读的问题.该级别保证了在同一个事务中多次读取同样记录的结果是一致的,但是理论上,可重复读隔离级别还是无法解决另外一个**幻读**(*Phantom Read*)的问题.所谓幻读,*指的是当某个事务在读取某个范围内的记录时,另外一个事务又在该范围内插入了新的记录,当之前的事务再次读取该范围的记录时,会产生**幻行**(*Phantom Row*)*.InnoDB和XtraDB存储引擎通过**多版本并发控制**(*MVCC,Multiversion Concurrency Control*)解决了幻读的问题.

***可重复读是MySQL的默认事务隔离级别***.

**SERIALIZABLE(可串行化)**:

​	SERIALIZABLE是最高的隔离级别.它通过强制事务串行执行,避免了前面说的幻读的问题.简单来说,**SERIALIZABLE会在读取的每一行数据上都加锁,所以可能导致大量的超时和锁争用的问题**.*实际应用中也很少用到这个隔离级别,只有在非常需要确保数据的一致性而且可以接受没有并发的情况下,才考虑采用该级别*.

| 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| :--------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED | Yes        | Yes              | Yes        | No     |
| READ COMMITTED   | No         | Yes              | Yes        | No     |
| REPEATABLE READ  | No         | No               | Yes        | No     |
| SERIALIZABLE     | No         | No               | No         | Yes    |

#### 死锁

死锁是指两个或者多个事务在统一资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环的现象.当多个事务视图以不同的顺序锁定资源时,就可能会产生死锁.多个事务同时锁定同一个资源时,也会产生死锁.

为了解决这种问题,数据库系统实现了各种死锁检测和死锁超时机制.越复杂的系统,比如InnoDB存储引擎,越能检测到死锁的循环依赖,并立即返回一个错误.还有一种解决方式:*当查询的时间达到所等待超时的设定后放弃锁请求,这种方式通常来说不太好.InnoDB目前处理死锁的方法是,将持有最少行级排他锁的事务进行回滚(这是相对比较简单的死锁回滚算法)*.

锁的行为和顺序是和存储引擎相关的.以同样的顺序执行语句,有些存储引擎会产生死锁,有些则不会.死锁的产生有双重原因:**有些是因为真正的数据冲突,这种情况通常很难避免,但有些则完全是由于存储引擎的实现方式导致的**.

#### 事务日志

事务日志可以帮助提高事务的效率.**使用事务日志,存储引擎在修改表的数据时只需要修改其内存拷贝,再把该修改行为记录到持久在硬盘的事务日志中,而不用个每次豆浆修改的数据本身持久到磁盘.事务日志采用的是追加的方式,因此写日志的操作是磁盘上一小块区域内的顺序I/O,而不像随机I/O需要在磁盘的多个地方移动磁头,所以采用事务日志的方式相对来说要快得多**.事务日志持久以后,内存中被修改的数据在后台可以慢慢地刷回到磁盘.目前大多数存储引擎都是这样实现的,我们通常称之为预写式日志(Write-Ahead Logging),修改数据需要写两次磁盘.

### MySQL中的事务

MySQL提供了两种事务型的存储引擎:InnoDB和NDB Cluster.另外还有一些第三方存储引擎也支持事务,比较知名的包括XtraDB和PBXT.

#### 自动提交(AUTOCOMMIT)

MySQL默认采用自动提交(AUTOCOMMIT)模式.也就是说,如果不是显式地开始一个事务,则每个查询都被当做一个事务执行提交操作.在当前连接中,可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式.

![image-20181126144955319](/Users/admin/Blog/MarkdownPhotos/MySQL/image/AUTOCOMMIT.png)

1或者ON表示启用,0或者OFF表示禁用.当AUTOCOMMIT=0时,所有的查询都是在一个事务中,直到显式地执行COMMIT提交或者ROLLBACK回滚,该事务结束,同时又开始了另一个新事务.修改AUTOCOMMIT对非事务型的表,比如MyISAM或者内存表,不会有任何影响.对这类表来说,没有COMMIT或者ROLLBACK的概念,也可以说是相当于一直处于AUTOCOMMIT启用的模式.

另外还有一些命令,在执行之前会强制执行COMMIT提交当前的活动事务.典型的例子,在数据定义语言(DDL)中,如果是会导致大量数据改变的操作,比如ALTER TABLE,就是如此.另外还有LOCK TABLES等其他语句也会导致同样的效果.

MySQL可以通过执行SET TRANSACTION ISOLATION LEVEL命令来设置隔离级别.新的隔离界别会在下一个事务开始的时候生效.可以在配置文件中设置整个数据库的隔离界别,也可以只改变当前会话的隔离级别:

```mysql
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED
```

**MySQL能够识别所有的4个ANSI隔离级别,InnoDB引擎也支持所有的隔离级别.**

#### 在事务中混合使用存储引擎

MySQL服务器层不管理事务,事务是由下层的存储引擎实现的,所以在同一个事务中,使用多种存储引擎是不可靠的.

如果在事务中混合使用了事务型和非事务型的表(InnoDB和MyISAM),在正常提交的情况下不会有什么问题.***但如果该事务需要回滚,非事务型的表上的变更就无法撤销,这回导致数据库处于不一致的状态,这种情况很难修复,事务的最终结果将无法确定***.

在非事务型的表上执行事务相关操作的时候,MySQL同行不会发出提醒,也不会报错.有时候只有回滚的时候才会发出一个警告:"某些非事务型的表上的变更不能被回滚".

#### 隐式和显式锁定

InnoDB采用的是两阶段锁定协议(*two-phase locking protocol*).在事务执行过程中,随时都可以执行锁定,锁只有在执行*COMMIT*或者*ROLLBACK*的时候才会释放,并且所有的锁都是在同一时刻被释放.这些都是隐式锁定,InnoDB会根据隔离级别在需要的时候自动加锁.

另外,InnoDB也支持通过特定的语句进行显示锁定,这些语句不属于SQL规范:

```mysql
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
```

MySQL也支持LOCK TABLES和UNLOCK TABLES语句,这是在服务器层实现的,和存储引擎无关.他们有自己的用途,并不能替代事务处理.

> 建议:除了事务中禁用了AUTOCOMMIT,可以使用LOCK TABLES之外,其他任何时候都不要显式地执行LOCK TABLES,不管使用的是什么存储引擎.

### 多版本并发控制

基于提升并发性能的考虑,MySQL等数据库系统一般都实现了多版本并发控制(MVCC).

可以认为MVCC是行级锁的一个变种,但是它在很多情况下避免了加锁操作,因此开销更低.虽然实现机制有所不同,但大都实现了非阻塞的读操作,写操作也只锁定必要的行.

MVCC的实现,**是通过保存数据在某个时间点的快照来实现的.也就是说,不管需要执行多长时间,每个事务看到的数据都是一致的.根据事务开始的时间不同,每个事务对同一张表,同一时刻看到的数据可能是不一样的**.

不同存储引擎的MVCC实现是不同的,典型的有**乐观(*optimistic*)并发控制**和**悲观(*pessimistic*)并发控制**

InnoDB的MVCC是通过在每行记录后面保存两个隐藏的列来实现的.这两个列,一个保存了行的创建时间,一个保存行的过期时间(或删除时间).当然存储的并不是实际的时间值,而是系统版本号(system version number).*每开始一个新的事务,系统版本号都会自动递增.事务开始时刻的系统版本号会作为事务的版本号,用来和查询到的每行记录的版本号进行比较*.

保存这两个额外的系统版本号,使大多数读操作都可以不用加锁.这样设计使得读数据操作很简单,性能很好,并且也能保证只会读取到符合标准的行.不足之处是每行记录都需要额外的存储空间,需要做更多的行检查工作,以及一些额外的维护工作.

MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作.其他两个隔离级别都和MVCC不兼容,因为READ UNCOMMITTED总是读取最新的数据行,而不是符合当前事务版本的数据行.而SERIALIZABLE则会对所有读取的行都加锁.

### MySQL的存储引擎

***MySQL将每个数据库(也可以称之为schema)保存为数据目录下的一个子目录.创建表时,MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义***.因为MySQL使用文件系统的目录和文件来保存数据库和表的定义,大小写敏感性和具体的平台密切相关.在windows中,大小写是不敏感的,而在类Unix中则是敏感的.**不同的存储殷勤保存数据和索引的方式是不用的,但表的定义则是在MySQL服务层统一处理的**.

#### InnoDB存储引擎

InnoDB是MySQL的默认事务型存储引擎,也是最重要,使用最广泛的存储引擎.*它被设计用来处理大量的短期(short-lived)事务,短期事务大部分情况是正产提交的,很少会被回滚.InnoDB的性能和自动崩溃恢复特性,使得它在非事务型存储的需求中也很流行.

##### InnoDB概览

InnoDB的数据存储在表空间(tablespace)中,表空间是由InnoDB管理的一个黑盒子,由一系列的数据文件组成.

InnoDB采用MVCC来支持高并发,并且实现了四个基本的隔离级别.其默认级别是REAPEATABLE READ(可重复读),并且通过间隙锁(next-key locking)策略方式幻读的出现.间隙锁使得InnoDB不仅仅锁定查询涉及的行,还会对索引中的间隙进行锁定,以防止幻影行的插入.

InnoDB表是基于聚簇索引建立的.**聚簇索引对主键查询有很高的性能,不过它的二级索引(secondary index,非主键索引)中必须包含主键列,所以如果主键列很大的话,其他的索引都会很大.因此,若表上的索引较多的话,主键应当尽可能的小.InnoDB的存储格式是平台独立的**(与系统无关).

InnoDB内部做了很多优化,包括从磁盘读取数据是采用的可预测性预读,**能够自动在内存中创建hash索引以加速读操作的自适应哈希索引(*adaptive hash index*)**,以及能够加速插入操作的插入缓冲区(*insert buffer*)等.

#### MyISAM存储引擎

在MySQL 5.1及之前的版本,MyISAM是默认的存储引擎.MyISAM提供了大量的特性,包括全文索引,压缩,空间函数(GIS)等,但MyISAM不支持事务和行级锁,而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复.*对于只读的数据,或者表比较小,可以忍受修复(repair)操作,则依然可以继续使用MyISAM*.

##### 存储

MyISAM会将表存储在两个文件中:数据文件和索引文件,分别以*.MYD*和*.MYI*为扩展名.MyISAM表可以包含动态或者静态(长度固定)行.MySQL会根据表的定义来决定采用何种行格式.MyISAM表可以存储的行记录数,一般受限于可用的磁盘空间,或者操作系统中单个文件的最大尺寸.

##### MyISAM特性

- 加锁与并发



  MyISAM对整张表加锁,而不是针对行,读取时会对需要读到的所有表加共享锁,写入时则对表加排他锁.**但是在表有读取查询的同事,也可以往表中插入新的记录(这被称为并发插入,CONCURRENT INSERT)**.

- 修复

  这里的修复和事务恢复以及崩溃恢复是不同的概念.

- 索引特性

  对于MyISAM表,即使是BLOB和TEXT等长字段,也可以基于其前500个字符创建索引.MyISAM也支持全文索引,这是一种基于分词创建的索引,可以支持复杂的查询.

- 延迟更新索引键(delayed key write)

  创建MyISAM表的时候,如果指定了DELAY_KEY_WRITE选项,在每次修改执行完成时,不会立刻将修改的索引数据写入磁盘,而是会写到内存的键缓冲区(*in-memory key buffer*),只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘.这种方式虽然可以提升写入性能,但是在主机崩溃时有索引损坏的危险.

##### MyISAM压缩表

如果表再创建并导入数据以后,不会在进行修改操作,那么这样的表或许适合采用MyISAM压缩表.

**压缩表是不能进行修改的(除非先将表解除压缩,修改数据,然后再次压缩).压缩表可以极大地减少磁盘空间占用,因此也可以减少磁盘I/O,从而提升查询性能.压缩表也支持索引,但是索引只读.**

**压缩时表中的记录是独立压缩的,所以读取单行的时候不需要去解压整个表(甚至也不解压行所在的整个页面)**.

#### 转换表的引擎

- ALTER TABLE

  ```mysql
  ALTER TABLE mytable ENGINE = InnoDB;
  ```

  上述语法可以使用任何存储引擎,但有一个问题:需要执行很长时间.MySQL会按行将数据从原表复制到一张新的表中,在复制期间可能会消耗系统所有的I/O能力,同时原表上回加上读锁.

  如果转换表的存储引擎,将会失去和原引擎相关的所有特性.例如,如果将一张InnoDB表转换为MyISAM,然后再转换回InnoDB,原InnoDB表上所有的外键将丢失.

- 导出与导入

  为了更好地控制转换的过程,可以使用mysqldump工具将数据导出到文件,然后修改文件中*CREATE TABLE*语句的存储引擎选项,注意同时修改表名.

- 创建和查询(*CREATE和SELECT*)

  不需要导出整个表的数据,而是先创建一个新的存储引擎表,然后利用*INSERT ... SELECT*语法来导数据